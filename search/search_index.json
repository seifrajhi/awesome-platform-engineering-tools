{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Awesome Platform Engineering Tools","text":"<p>A curated list of Platform and Production Engineering tools - Maintained by Saif Rajhi</p> <p> </p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Awesome Platform Engineering Tools</li> <li>Contents</li> <li>Articles and Presentations and Books</li> <li>Newsletters, Chats and Podcasts</li> <li>Specifications</li> <li>Reference Architecture</li> <li>AI powered platform tools</li> <li>Development<ul> <li>Source Code Management</li> <li>Feature flags and change management</li> <li>Project Management \\&amp; Issue Tracking Software</li> <li>Bug / Defect Tracking Software</li> <li>Code Editors and IDE's</li> </ul> </li> <li>Continuous Testing</li> <li>Continuous Integration<ul> <li>Build</li> <li>Integration</li> </ul> </li> <li>Continuous Delivery<ul> <li>Deployment</li> <li>Automation and Collaboration</li> <li>Infrastructure orchestration</li> <li>Container</li> <li>Container Registry</li> <li>Container Orchestration</li> </ul> </li> <li>Continuous Monitoring</li> <li>Incident Management / Incident Response / IT Alerting / On-Call<ul> <li>IT Service Management</li> <li>Incident Communication</li> </ul> </li> <li>Security</li> <li>Internal Developer Portal</li> <li>Path to senior platform engineer handbook</li> <li>Miscellaneous and Related</li> <li>Notions and concepts</li> <li>Stargazers over time</li> <li>Licence</li> </ul>"},{"location":"#articles-and-presentations-and-books","title":"Articles and Presentations and Books","text":"<ul> <li>Chances are you don't need a platform team - How to minimize your platform and maximize user value by @bschaatsbergen .</li> <li>How To Create A Complete Internal Developer Platform (IDP)? - It's time to build an internal developer platform (IDO) with Crossplane, Argo CD, SchemaHero, External Secrets Operator (ESO), GitHub Actions, Port, and a few others by @vfarcic .</li> <li>What does it take to become a Platform Engineer? .</li> <li>Platform Engineering How Did We Get Here  .</li> <li>Can we say that Platform Engineering is DevSec(Rel)Ops? .</li> <li>The Practical Guide to Internal Developer Portals - The next big thing in DevOps is platform engineering, and the main tool it uses is the internal developer portal. Read this guide to understand what can be done with portals and why they matter .</li> <li>Platform Engineering on Kubernetes - A book that teaches how to build custom platforms on top of Kubernetes using open-source tools such as Dapr, Knative, Argo CD and Rollouts, and Tekton. It explores the tools and techniques needed to overcome common cloud-native challenges and is suitable for readers with different expertise levels .</li> <li>Build Your IDP at Light Speed with a Platform Reference Architecture - Now organizations have a standard, proven, scalable, and repeatable pattern for internal developer platforms that\u2019s applicable to any tooling choice .</li> <li>What Is Platform Engineering? Role, Principles &amp; Benefits.</li> <li>How to Design an Internal Developer Platform.</li> <li>A Platform Team Product Manager Determines DevOps Success.</li> <li>Platform Engineering KPIs.</li> <li>Platform Engineering: Creating your Internal Developer Platform.</li> <li>The 10 Platform Engineering Tools To Use in 2022.</li> <li>Platform Engineering at Palo Alto Networks.</li> <li>Platform Engineering story from a CTO: WHY, WHAT, HOW.</li> <li>Create Preview Environments with Terraform, GitHub Actions, and Vercel.</li> <li>Guide To Internal Developer Portals.</li> <li>Introducing KBOM \u2013 Kubernetes Bill of Materials .</li> <li>Platform Engineering Is Not Just about the Tools - Platform engineering isn\u2019t solely about the tools and components but also about alignment within the organization and a special focus on understanding user needs .</li> <li>Platform Engineering Rules the Day -  Eight Key Themes .</li> <li>Wwhat is Platform Engineering and why it is important for better developer experience - Some of the core tenets of Platform Engineering.</li> <li>5 myths about platform engineering: what it is and what it isn\u2019t - Five common myths about platform engineering.</li> <li>The ultimate guide to platform engineering - Stay competetive: embrace platform engineering .</li> <li>Top Platform Engineering KPIs You Need to Monitor - A curated list of top platform engineering KPIs that software teams must monitor .</li> <li>Can ops actually do product management - Platform engineering problems: can ops actually do product management?.</li> <li>Pulumi Platform Engineering - Accelerate, Scale and Secure AI Innovation with Pulumi Platform Engineering .</li> <li>Insights to enable your platform engineering team to improve agility and customer focus - A Platform engineering that empowers users and reduces risk .</li> <li>Can Your Developers Benefit from Platform Engineering? - Will designing tools and workflows to bring self-service to software development help developers work more efficiently? .</li> <li>Platform Engineering: A Guide for Technical, Product, and People Leaders - This book guides you on adopting a developer-centric approach to platform engineering, understanding and building platform teams, automating infrastructure, and managing platform scalability and team dynamics. It also covers the role of a platform product manager and improving developer experience through self-service infrastructure .</li> <li>Effective Platform Engineering - Learn to design and build platforms and tools that maximize developer efficiency .</li> <li>The Road to Simplicity - What platform engineering can learn from automobile design .</li> <li>Top 7 Platform Engineering Tools - Key platform engineering tools for developers .</li> <li>Platform Engineering Podcast - This podcast caters to professionals and enthusiasts passionate about the intricacies of platform architecture, cloud operations, and scaling DevOps practices .</li> <li>A brief history of Platform Engineering - How the shift to cloud native applications gave rise to a new practice called Platform engineering .</li> <li>Platform Engineering Essential Tools - Key Platform Engineering tools .</li> <li>Platform as a Product - Platform as a Product: What, Why, and How? .</li> <li>State of Platform Engineering - The 2024 State of Platform Engineering? Fledgling at Best .</li> <li>4000 microservices, 8 million customers, 1 Internal Developer Platform  The story of how Sicredi, a credit union, with over 8 million clients, 2700 branches, and over 45,000 employees embarked on building an Internal Developer Platform to serve its thousands of developers - .</li> <li>Platform Engineering: A Workshop to Help Map Your Strategy - Stakeholders from across an organization can decide together what their internal developer platform should do .</li> <li>Combining practical Platform Engineering with Crossplane and ArgoCD - A hands-on look into tools and their integrated usage can help kickstart your knowledge about Platform Engineering patterns. Therefore let's dive into two top frameworks when it comes to Platform Engineering today: Crossplane &amp; ArgoCD. Both alone can already be great choices, but combining their powers can unlock a whole new level .</li> <li>Platform tooling landscape - Based on 100s of platform engineering setups in organizations of all sizes, this landscape distills the best practices in designing Internal Developer Platforms. .</li> <li>How Platform Engineering Empowers Users and Reduces Risk? - This blog focuses on how platform engineering reduces complexity, enhances user autonomy, and minimizes risks in modern tech ecosystems. .</li> <li>Why Every Platform Engineer Should Care About Kubernetes Operators from Pulumi Blog - Platform Engineer should konw that successful Kubernetes-powered platform is the use of Kubernetes Operators, as they are a great way to automate operational tasks and the lifecycle of complex applications and services on Kubernetes. .</li> <li>Principal Engineer Roles Framework - The Principal Engineer Roles Framework by Mai-Lan Tomsen Bukovec outlines six distinct roles (Sponsor, Guide, Catalyst, Tie Breaker, Catcher, and Participant) to optimize impact, support skills development, and maintain clarity and alignment in fast-paced environments. .</li> </ul>"},{"location":"#newsletters-chats-and-podcasts","title":"Newsletters, Chats and Podcasts","text":"<ul> <li>Platform Engineering Certification - Cloud Native Computing Foundation Expands Certification to Platform Engineering.</li> <li>Platform Engineering</li> <li>Internal Developer Platform</li> <li>The New Stack</li> <li>Resources about Internal Platform teams and products</li> <li>Humanitec (Platform Engineering) Blog</li> <li>InfoQ Platform Engineering Articles</li> <li>Port Blog</li> <li>Platform weekly</li> <li>Platformengineering.org Slack</li> <li>What's Platform Engineering? And How Does It Support DevOps?</li> <li>The New Stack Podcast</li> <li>Platform Engineering with Nicholas Eberts</li> </ul>"},{"location":"#specifications","title":"Specifications","text":"<ul> <li>OAM: One Application Model - An open model for defining cloud native apps.</li> <li>Argonaut - Deploy apps and infrastructure on your cloud in minutes.</li> <li>devtron - An open source Internal Developer Platform for Kubernetes.</li> <li>SaaS Backstage Roadie - SaaS Backstage. Simple, safe, and more powerful.</li> <li>ZYMR - We excell at Platform engineering.</li> <li>CTO: platform for platform teams -  The platform for platform teams : Easily implement your vision for the perfect developer platform without having to build everything from scratch. We\u2019re more than just a CI/CD pipeline. We\u2019re an intelligent automation platform for all of your development workflows.</li> <li>score - One easy way to configure all your workload. Everywhere.</li> <li>kubevela - Make shipping applications more enjoyable.</li> <li>kusionstack - Open Tech Stack to build self-service, collaborative, reliable and sustainable Internal Developer Platform.</li> <li>Cloud Native Operational Excellence (CNOE) - CNOE will enable organizations to navigate tooling sprawl and technology churn by coordinating contributions, offering tools, and providing neutral guidance on technology choices to deliver IDPs.</li> <li>OpenGitOps - OpenGitOps is a set of open-source standards, best practices, and community-focused education to help organizations adopt a structured, standardized approach to implementing GitOps.</li> <li>Open Platform for Enterprise AI - An ecosystem orchestration framework to integrate performant GenAI technologies &amp; workflows leading to quicker GenAI adoption and business value.</li> <li>karpor: Intelligence for Kubernetes. - World's most promising Kubernetes visualization Tool for developer and platform engineering teams.</li> </ul>"},{"location":"#reference-architecture","title":"Reference Architecture","text":"<ul> <li>The Reference Architecture for Agility is a technology-neutral logical architecture based on a disaggregated cloud-based model - A proven approach to helping every development organization become an integration agile organization.</li> <li>CloudGeometry Reference Architecture - CloudGeometry Reference Architecture for simplifying the creation and management of DevOps and Cloud resources.</li> <li>AWS Reference Architecture implementation - How to spin up your Humanitec AWS Reference Architecture.</li> <li>GCP Reference Architecture implementation - How to spin up your Humanitec Google Cloud Reference Architecture Implementation.</li> <li>Azure Reference Architecture implementation - How to spin up your Humanitec Azure Reference Architecture.</li> <li>IBM Cloud Reference Architecture -  IBM Infrastructure Automation.</li> <li>Awesome Software Architecture - A curated list of resources on software architecture.</li> </ul>"},{"location":"#ai-powered-platform-tools","title":"AI powered platform tools","text":"<ul> <li>InfraStack AI - AI-Powered Observability Copilot.</li> <li>AI-Powered Incident Management - A solution that combines an on-call AI copilot and end-to-end automation.</li> <li>Monolith - No-code AI software built for engineers.</li> <li>Viktor - Implement AI in your engineering workflow.</li> <li>initializ.ai - AI-Driven Unified DevSecOps Platform.</li> </ul>"},{"location":"#development","title":"Development","text":""},{"location":"#source-code-management","title":"Source Code Management","text":"<ul> <li>Git</li> <li>GitHub</li> <li>Gitlab</li> <li>Bitbucket</li> <li>Fossil</li> <li>Mercurial</li> <li>Perforce Helix Core</li> <li>Subversion (SVN)</li> <li>Nvim - hyperextensible Vim-based text editor.</li> <li>Unleash - Open-source feature management solution built for developers.</li> </ul>"},{"location":"#feature-flags-and-change-management","title":"Feature flags and change management","text":"<ul> <li>OpenFeature: community-developed specification to standardise feature flag management</li> <li>Launchdarkly: feature flags paid service</li> <li>Git Guide: Generate A Changelog From Your Git Commit Messages</li> <li>Update NPM, pip, Gem etc. dependencies</li> <li>Upgrade microservices</li> <li>Upgrade JavaScript or TypeScript codebases</li> <li>Git Qovery: PR/Commit Preview Environments Platform (paid)</li> <li>Bunnyshell: production replica environments for dev, QA and Staging</li> <li>LocalStack: A fully functional local AWS cloud stack</li> <li>Gitpod: cloud development environments</li> <li>okteto: spin up dev and preview environments</li> </ul>"},{"location":"#project-management-issue-tracking-software","title":"Project Management &amp; Issue Tracking Software","text":"<ul> <li>Jira</li> <li>Trello</li> <li>Zoho Sprints</li> <li>Taiga</li> <li>Wrike</li> <li>Asana</li> <li>Monday.com</li> <li>Clickup</li> <li>Basecamp</li> <li>Rally</li> <li>Teamwork</li> <li>Redmine</li> <li>Freedcamp</li> <li>Shortcut</li> <li>Azure Boards</li> <li>GitHub Projects</li> <li>GitLab Boards</li> <li>Bitbucket Issues</li> <li>Linear</li> </ul>"},{"location":"#bug-defect-tracking-software","title":"Bug / Defect Tracking Software","text":"<ul> <li>Bugzilla</li> <li>Bugsee</li> <li>Instabug</li> <li>Zoho BugTracker</li> <li>Bugasura</li> <li>Mantis Bug Tracker</li> <li>Github Issues</li> </ul>"},{"location":"#code-editors-and-ides","title":"Code Editors and IDEs","text":"<ul> <li>GNU Emacs</li> <li>Notepad++</li> <li>Atom</li> <li>Visual Studio Code</li> <li>Sublime Text</li> <li>Vim</li> <li>Eclipse</li> <li>GNU Nano</li> <li>UltraEdit</li> <li>TextMate</li> <li>gedit</li> <li>WebStorm</li> <li>IntelliJ IDEA</li> <li>PyCharm</li> <li>Eclipse Che</li> </ul>"},{"location":"#continuous-testing","title":"Continuous Testing","text":"<ul> <li>Selenium</li> <li>JUnit</li> <li>TestNG</li> <li>NUnit</li> <li>TestSigma</li> <li>Unified Functional Testing (UFT)</li> <li>Tricentis Tosca</li> <li>IBM Rational Functional Tester</li> <li>TestComplete</li> <li>Waitr</li> <li>Zephyr</li> <li>accelQ</li> <li>Apache jMeter</li> <li>Appium</li> <li>steadybit</li> <li>k6</li> <li>Apache JMeter</li> <li>Gatling</li> <li>Cypress</li> <li>TestRail</li> </ul>"},{"location":"#continuous-integration","title":"Continuous Integration","text":""},{"location":"#build","title":"Build","text":"<ul> <li>Ninja</li> <li>Meson</li> <li>CMake</li> <li>Autotools/Automake</li> <li>premake</li> <li>Maven</li> <li>Ant</li> <li>Gradle</li> <li>Make</li> <li>Cake</li> <li>Rake</li> <li>MS Build</li> <li>Drill</li> <li>Hydra</li> <li>Bazel</li> <li>Azure DevOps</li> </ul>"},{"location":"#integration","title":"Integration","text":"<ul> <li>Jenkins</li> <li>Bamboo</li> <li>Hudson</li> <li>CircleCI</li> <li>TeamCity</li> <li>Gitlab CI</li> <li>Travis CI</li> <li>AWS CodeStar</li> <li>Buildbot</li> <li>Semaphore CI</li> <li>Concourse CI</li> <li>Abstruse CI</li> <li>Appcenter</li> <li>Appveyor</li> <li>Assertible</li> <li>Badwolf</li> <li>Britise</li> <li>Buildkite</li> <li>Chrono CI</li> <li>Codacy</li> <li>CodeClimate</li> <li>CodeFresh</li> <li>Codeship</li> <li>Continuousphp</li> <li>Drone</li> <li>Hound CI</li> <li>Probo.CI</li> <li>Solano CI</li> <li>Visual Studio Team Services</li> <li>Go CD</li> <li>Pipelight</li> </ul>"},{"location":"#continuous-delivery","title":"Continuous Delivery","text":""},{"location":"#deployment","title":"Deployment","text":"<ul> <li>AWS CodeDeploy</li> <li>ElectricFlow</li> <li>Octopus Deploy</li> <li>IBM UrbanCode</li> <li>DeployBot</li> <li>Shippable</li> <li>Codar Continuous Delivery</li> <li>Wercker</li> <li>Humanitec</li> <li>ArgoCD</li> <li>FluxCD</li> <li>Jenkins X - CI/CD including everything you need to start exploring Kubernetes</li> <li>Tekton</li> <li>Buddy Works</li> <li>werf</li> <li>Google Cloud Build</li> <li>Spinnaker</li> <li>Kluctl - Easily handle Kubernetes deployments of any size, complexity, and across various environments using the push based CLI or pull based GitOps.</li> <li>Walrus - An open-source application management platform based on IaC tools including OpenTofu, Terraform and others. It helps platform engineers build golden paths for developers and empowers developers with self-service capabilities.</li> <li>dyrector.io - dyrector.io is a self-hosted continuous delivery &amp; deployment platform with version management.</li> <li>ketch - Application delivery framework that facilitates the deployment and management of applications on Kubernetes using a simple command line interface.</li> </ul>"},{"location":"#automation-and-collaboration","title":"Automation and Collaboration","text":"<ul> <li>Digger - Infrastructure as code management platform that enables you to run OpenTofu &amp; Terraform in your CI/CD system.</li> <li>Atlantis \u2014 Open Source Terraform Pull Request Automation tool.</li> <li>Env0 \u2014 Automate and Manage IaC at Scale, With Confidence</li> <li>Spacelift \u2014 Spacelift is a sophisticated CI/CD platform for OpenTofu, Terraform, Terragrunt, CloudFormation, Pulumi, Kubernetes, and Ansible.</li> <li>Terramate \u2014 Terramate adds powerful capabilities such as code generation, stacks, orchestration, change detection, data sharing and more to Terraform.</li> <li>Terrateam \u2014 Infrastructure as Code CI/CD for GitHub</li> <li>OTF \u2014 An open source alternative to terraform enterprise.</li> <li>Hatchet \u2014 An all-in-one platform to automate, secure and monitor Terraform</li> <li>GitHub Actions - Automate, customize, and execute your software development workflows right in your repository</li> <li>Runme - Infrastructure Notebooks Built with Markdown. Runme is a free tool that enables Markdown files to become runnable notebooks. You can use scripts in Shell, Perl, Python, and more.</li> <li> Earthly - A versatile, approachable CI/CD framework that runs every pipeline inside containers, giving you repeatable builds that you write once and run anywhere.</li> </ul>"},{"location":"#infrastructure-orchestration","title":"Infrastructure orchestration","text":"<ul> <li>Vagrant</li> <li>Puppet</li> <li>Chef</li> <li>SaltStack</li> <li>Ansible</li> <li>Terraform</li> <li>OpenTofu</li> <li>Terragrunt - DRY and maintainable Terraform code.</li> <li>Pulumi</li> <li>AWS CloudFormation</li> <li>Rundeck</li> <li>Selefra</li> <li>Scalr</li> <li>Google Cloud Deployment Manager</li> <li>OPS</li> <li>Helm - The package manager for Kubernetes</li> <li>Helmfile - Deploy Kubernetes Helm Charts</li> <li>Crossplane</li> <li>Packer</li> <li>Kubestack</li> <li>Shipyard - Ephemeral environment management platform.</li> </ul>"},{"location":"#container","title":"Container","text":"<ul> <li>Depot</li> <li>Docker</li> <li>Turbo.NET</li> <li>WinDocks</li> <li>Podman</li> <li>containerd</li> <li>OpenShift</li> </ul>"},{"location":"#container-registry","title":"Container Registry","text":"<ul> <li>Docker Hub</li> <li>Google Container Registry</li> <li>Amazon ECR</li> <li>Gitlab Container Registry</li> <li>JFrog Artifactory</li> <li>Quay.io</li> <li>Azure Container Registry</li> <li>Oracle Container Registry</li> <li>Nexus Container Registry</li> <li>Harbor</li> </ul>"},{"location":"#container-orchestration","title":"Container Orchestration","text":"<ul> <li>Kubernetes</li> <li>Nomad</li> <li>Docker Swarm</li> <li>Apache Mesos - with Marathon</li> </ul>"},{"location":"#continuous-monitoring","title":"Continuous Monitoring","text":"<ul> <li>AWS CloudWatch</li> <li>DebugBear</li> <li>Prometheus</li> <li>StackDriver</li> <li>Sensu</li> <li>Sentry</li> <li>CopperEgg</li> <li>Crashlytics</li> <li>Kapacitor</li> <li>loggly</li> <li>logmatic</li> <li>Logstash</li> <li>MongoDB Atlas</li> <li>MongoDB Cloud Manager</li> <li>NewRelic</li> <li>Papertrail</li> <li>Pingdom</li> <li>ServerDensity</li> <li>Zabbix</li> <li>InsightOps</li> <li>AppSignal</li> <li>Grafana</li> <li>VictoriaMetrics</li> <li>Chaos Genius</li> <li>Thanos</li> <li>Mimir</li> <li>Hydrozen.io - Uptime monitoring &amp; Statuspages</li> <li>Steampipe.io - Universal SQL interface to any cloud API</li> <li>Better Stack</li> <li>Netdata</li> <li>DoctorGPT - Brings GPT into production for application log error monitoring</li> <li>Dynatrace</li> <li>Datadog</li> <li>Elastic APM</li> <li>Healthchecks.io</li> <li>OnlineOrNot - Uptime monitoring for websites, APIs, and cron jobs, with integrated status pages.</li> <li>ELK Stack (Elasticsearch, Logstash, Kibana)</li> <li>VictoriaLogs database for logs from VictoriaMetrics</li> <li>OpenTelemetry</li> <li>Fluentd CNCF- a Distributed Tracing Platform</li> <li>Jaeger CNCF: Unified Logging Layer</li> <li>Infracost- cost estimates for Terraform</li> <li>OpenCost \u2014 open source cost monitoring tool for Kubernetes</li> <li>Apache SkyWalking \u2014 Application Performance Monitoring</li> <li>SigNoz- an open-source alternative to DataDog, NewRelic, etc.</li> <li>Loki - low cost open source logging; self-hosted or SaaS</li> <li>SigLens</li> </ul>"},{"location":"#incident-management-incident-response-it-alerting-on-call","title":"Incident Management / Incident Response / IT Alerting / On-Call","text":"<ul> <li>Squadcast</li> <li>PagerDuty</li> <li>VictorOps</li> <li>OpsGenie</li> <li>AlertOps</li> <li>Blameless</li> <li>Jira Ops</li> <li>OnPage</li> <li>PagerTree</li> <li>Cabot</li> <li>AlertAgility</li> <li>xMatters</li> <li>Derdack Enterprise Alert</li> <li>Bigpanda</li> <li>OpenDuty</li> <li>ngDesk</li> <li>Geneos</li> <li>FireHydrant</li> <li>SLO exporter</li> <li>SLO Calculator</li> <li>Rootly</li> <li>Grafana OnCall</li> <li>Keep - CLI for alerting</li> <li>Better Stack</li> <li>Everbridge</li> <li>Moogsoft</li> <li>incident.io</li> <li>AlertManager</li> <li>rootly - Manage incidents directly from Slack</li> <li>Pagerly - Manage Oncalls and Incidents on Slack</li> </ul>"},{"location":"#it-service-management","title":"IT Service Management","text":"<ul> <li>Homer - A very simple static homepage for your server.</li> <li>FreshService</li> <li>ServiceNow</li> <li>BMC Remedy</li> <li>Jira Service Management(formerly Jira Service Desk)</li> <li>Samanage</li> <li>Cherwell</li> <li>SysAid</li> <li>ManageEngine Servicedesk plus</li> <li>Zendesk</li> </ul>"},{"location":"#incident-communication","title":"Incident Communication","text":"<ul> <li>Squadcast Statuspages</li> <li>StatusPal - communicate incidents and maintenance effectively with a beautiful hosted status page.</li> <li>Hydrozen.io Statuspages</li> <li>Atlassian Statuspages</li> <li>Instatus Statuspages - Quick and beautiful status page.</li> <li>Cachet</li> </ul>"},{"location":"#security","title":"Security","text":"<ul> <li>Sysdig Secure</li> <li>Aqua Security</li> <li>Wiz</li> <li>Wazuh</li> <li>Qualys Cloud Platform</li> </ul>"},{"location":"#internal-developer-portal","title":"Internal Developer Portal","text":"<ul> <li>Port</li> <li>Backstage Software Catalog</li> <li>OpsLevel</li> <li>KusionStack</li> <li>KubeStack</li> <li>Radius app - Open-source, cloud-native, application platform that enables developers and the operators that support them to define, deploy, and collaborate on cloud-native applications across public clouds and private infrastructure.</li> <li>Mia platform - Don\u2019t waste time setting up your platform, just push the code!.</li> <li>Humanitec - Powering your Internal Developer Platform.</li> <li>Appvia - Increase Developer productivity with self-service.</li> <li>qovery - Deliver Self-Service Infrastructure Faster.</li> <li>Mogenius - The Kubernetes Operations Platform.</li> <li>Nullstone - An easy-to-use developer platform that enables developers to quickly deploy any application.</li> <li>Kratix  - A framework for building Platform-as-a-Product.</li> <li>cycloid -  Platform Engineering is DevOps with an action plan.</li> <li>Shipa - Shipa simplifies the way you deploy, secure, and manage applications across cloud native infrastructures by taking an application-centric approach.</li> <li>Upbound - The platform for platform teams.</li> <li>Kubero - A fully self-hosted Internal Developer Platform (IDP).</li> <li>Roadie Internal Developer Portal - SaaS-based Internal Developer Portal.</li> </ul>"},{"location":"#path-to-senior-platform-engineer-handbook","title":"Path to senior platform engineer handbook","text":"<ul> <li>Platform Engineer Career Path - Everything you need to know to senior platform engineer and beyond.</li> <li>A Guide to shaping your Platform Engineer career -  Platform Engineering career pathing.</li> </ul> <p>Platform Engineering serves as a distinct and valuable career path within an organization, complementing roles like DevOps and Site Reliability Engineering (SRE). While DevOps and SRE ensure smooth software development processes and reliable, scalable infrastructure respectively, Platform Engineers are entrusted with the unique responsibility of crafting the tools, processes, and platforms on which software development and operational tasks occur</p>"},{"location":"#platform-engineering-career-pathing","title":"Platform Engineering Career pathing","text":""},{"location":"#platform-engineering-roles-summary","title":"Platform Engineering Roles Summary","text":"<p>Junior Platform Engineer: Handles routine tasks, troubleshooting, cloud configurations, and code reviews. Skills: Basic scripting, cloud tech, containerization, Golang, Kubernetes.</p> <p>Platform Engineer: Implements features, security, system scaling, and CI/CD tools. Skills: Advanced cloud platforms, containerization, CI/CD, scripting, Golang, Kubernetes.</p> <p>Senior Platform Engineer: Designs architecture, mentors, manages projects, ensures security. Skills: System architecture, cloud computing, containerization, CI/CD, Golang, Kubernetes.</p> <p>Lead Platform Engineer: Leads team, manages projects, strategic decisions, stakeholder interaction. Skills: Systems design, project management, various tech stacks, Golang, Kubernetes.</p> <p>Staff Platform Engineer: Sets technical direction, standards, leads projects, guides cloud services. Skills: Multiple tech stacks, system design, performance, security, Golang, Kubernetes.</p> <p>Principal Platform Engineer: Technical leader, sets vision, strategy, engineering processes, cloud strategy. Skills: Broad tech expertise, strategic planning, complex engineering processes, Golang, Kubernetes.</p> <p>Platform Engineering Manager: Oversees teams, strategic direction, performance, budgeting, alignment with business. Skills: Technical background, budgeting, talent development, Golang, Kubernetes.</p> <p>Senior Manager, Platform Engineering: Sets organization-wide strategy, manages teams, cross-team collaboration, cloud strategy. Skills: Broad tech knowledge, business understanding, engineering management, Golang, Kubernetes.</p> <p>Director of Platform Engineering: Sets vision, plans execution, tech decisions, team structure, budget management, strategic planning. Skills: Vision setting, strategic planning, cloud strategy, Golang, Kubernetes.</p>"},{"location":"#miscellaneous-and-related","title":"Miscellaneous and Related","text":"<ul> <li>Cloud Native Interactive Landscape</li> <li>Platformengineering.org tooling list</li> <li>Platform Engineering list</li> <li>The 12 Platform Challenges</li> <li>DevSecOps resources and tooling</li> <li>Architecture- Cloud Design Patterns</li> </ul>"},{"location":"#notions-and-concepts","title":"Notions and concepts","text":""},{"location":"#fundamentals","title":"Fundamentals","text":"<ul> <li> <p>Keep it simple, stupid. You ain't gonna need it.</p> </li> <li> <p>You should think about what to do before you do it.</p> </li> <li> <p>You should try to talk about what you\u2019re planning to do before you do it.</p> </li> <li> <p>You should think about what you did after you did it.</p> </li> <li> <p>Be prepared to throw away something you\u2019ve done in order to do something different.</p> </li> <li> <p>Always look for better ways of doing things.</p> </li> <li> <p>\u201cGood enough\u201d isn\u2019t good enough.</p> </li> </ul>"},{"location":"#code","title":"Code","text":"<ul> <li> <p>Code is a liability, not an asset. Aim to have as little of it as possible.</p> </li> <li> <p>Build programs out of pure functions. This saves you from spending your brain power on tracking side effects, mutated state and actions at a distance.</p> </li> <li> <p>Use a programming language with a rich type system that lets you describe the parts of your code and checks your program at compile time.</p> </li> <li> <p>The expressivity of a programming language matters hugely. It\u2019s not just a convenience to save keypresses, it directly influences the way in which you write code.</p> </li> <li> <p>Choose a programming language that has a good module system, and use it. Be explicit about the public interface of a module, and ensure its interals don't leak out to client code.</p> </li> <li> <p>Code is a living construct that is never \u201cdone\u201d. You need to tend it like a garden, always improving and tidying it, or it withers and dies.</p> </li> <li> <p>Have the same high standards for all the code you write, from little scripts to the inner loop of your critical system.</p> </li> <li> <p>Write code that is exception safe and resource safe, always, even in contexts where you think it won\u2019t matter. The code you wrote in a little ad-hoc script will inevitably find its way into more critical or long-running code.</p> </li> <li> <p>Use the same language for the little tools and scripts in your system too. There are few good reasons to drop down into bash or Python scripts, and some considerable disadvantages.</p> </li> <li> <p>In code, even the smallest details matter. This includes whitespace and layout!</p> </li> </ul>"},{"location":"#design","title":"Design","text":"<ul> <li> <p>Modelling - the act of creating models of the world - is a crucial skill, and one that\u2019s been undervalued in recent years.</p> </li> <li> <p>Model your domain using types.</p> </li> <li> <p>Model your domain first, using data types and function signatures, pick implementation technologies and physical architecture later.</p> </li> <li> <p>Implement functionality in vertical slices that span your whole system, and iterate to grow the system.</p> </li> <li> <p>Resist the temptation to use your main domain types to describe interfaces or messages exchanged by your system. Use separate types for these, even if it entails some duplication, as these types will evolve differently over time.</p> </li> <li> <p>Prefer immutability always. This applies to data storage as well as in-memory data structures.</p> </li> <li> <p>When building programs that perform actions, model the actions as data, then write an interpreter that performs them. This makes your code much easier to test, monitor, debug, and refactor.</p> </li> <li> <p>Dependency management is crucial, so do it from day one. The payoff for this mostly comes when your system is bigger, but it\u2019s not expensive to do from the beginning and it saves massive problems later.</p> </li> <li> <p>Avoid circular dependencies, always.</p> </li> </ul>"},{"location":"#designing-systems","title":"Designing systems","text":"<ul> <li> <p>A better system is often a smaller, simpler system.</p> </li> <li> <p>To design healthy systems, divide and conquer. Split the problem into smaller parts.</p> </li> <li> <p>Divide and conquer works recursively: divide the system into a hierarchy of simpler sub-systems and components.</p> </li> <li> <p>Corollary: When designing a system, there are more choices than a monolith vs. a thousand \u201cmicroservices\u201d.</p> </li> <li> <p>The interface between parts is crucial. Aim for interfaces that are as small and simple as possible.</p> </li> <li> <p>Data dependencies are insidious. Take particular care to manage the coupling introduced by such dependencies.</p> </li> <li> <p>Plan to evolve data definitions over time, as they will inevitably change.</p> </li> <li> <p>Asynchronous interfaces can be useful to remove temporal coupling between parts.</p> </li> <li> <p>Every inter-process boundary incurs a great cost, losing type safety, and making it much harder to reason about failures. Only introduce such boundaries where absolutely necessary and where the benefits outweigh the cost.</p> </li> <li> <p>Being able to tell what your system is doing is crucial, so make sure it\u2019s observable.</p> </li> <li> <p>Telling what your system has done in the past is even more crucial, so make sure it\u2019s auditable.</p> </li> <li> <p>A modern programming language is the most expressive tool we have for describing all aspects of a system.</p> </li> <li> <p>This means: write configuration as code, unless it absolutely, definitely has to change at runtime.</p> </li> <li> <p>Also, write the specification of the system as executable code.</p> </li> <li> <p>And, use code to describe the infrastructure of your system, in the same language as the rest of the code. Write code that interprets the description of your system to provision actual physical infrastructure.</p> </li> <li> <p>At the risk of repeating myself: everything is code.</p> </li> <li> <p>Corollary: if you\u2019re writing JSON or YAML by hand, you\u2019re doing it wrong. These are formats for the machines, not for humans to produce and consume. (Don\u2019t despair though: most people do this, I do too, so you\u2019re not alone! Let's just try to aim for something better).</p> </li> <li> <p>The physical manifestation of your system (e.g. choices of storage, messaging, RPC technology, packaging and scheduling etc) should usually be an implementation detail, not the main aspect of the system that the rest is built around.</p> </li> <li> <p>It should be easy to change the underlying technologies (e.g. for data storage, messaging, execution environment) used by a component in your system, this should not affect large parts of your code base.</p> </li> <li> <p>You should have at least two physical manifestations of your system: a fully integrated in-memory one for testing, and the real physical deployment. They should be functionally equivalent.</p> </li> <li> <p>You should be able to run a local version of your system on a developer\u2019s computer with a single command. With the capacity of modern computers, there is absolutely no rational reason why this isn\u2019t feasible, even for big, complex systems.</p> </li> <li> <p>There is a running theme here: separate the description of what a system does from how it does it. This is probably the single most important consideration when creating a system.</p> </li> </ul>"},{"location":"#building-systems","title":"Building systems","text":"<ul> <li> <p>For a new system, get a walking skeleton deployed to production as soon as possible.</p> </li> <li> <p>Your master branch should always be deployable to production.</p> </li> <li> <p>Use feature branches if you like. Modern version control tools make merging easy enough that it\u2019s not a problem to let these be long-lived in some cases.</p> </li> <li> <p>Ideally, deploy automatically to production on every update to master. If that\u2019s not feasible, it should be a one-click action to perform the deployment.</p> </li> <li> <p>Maintain a separate environment for situations when you find it useful to test code separately from production. Avoid more than one such extra environment, as this introduces overheads and cost.</p> </li> <li> <p>Prefer feature flags and similar mechanisms to control what's enabled in production over separate test/staging environments and manual promotion of releases.</p> </li> <li> <p>Get in the habit of deploying from master to production from the very beginning of a project. Doing this shapes both your system and how you work with it for the better.</p> </li> <li> <p>In fact, follow all these practices from the very beginning of a new system. Retrofitting them later is much, much harder.</p> </li> </ul>"},{"location":"#technology","title":"Technology","text":"<ul> <li> <p>Beware of hyped or fashionable technologies. The fundamentals of computer science and engineering don\u2019t change much over time.</p> </li> <li> <p>Keep up with latest developments in technology to see how they can help you, but be realistic about what they can do.</p> </li> <li> <p>Choose your data storage backend according to the shape of data, types of queries needed, patterns of writes vs. reads, performance requirements, and more. Every use case is different.</p> </li> <li> <p>That said, PostgreSQL should be your default and you should only pick something else if you have a good reason.</p> </li> </ul>"},{"location":"#stargazers-over-time","title":"Stargazers over time","text":""},{"location":"#licence","title":"Licence","text":"<p>Shield: </p> <p>This work is licensed under a Creative Commons Attribution 4.0 International License.</p> <p></p> <p>Back to Top</p>"}]}